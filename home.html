<!-- ===== Firebase + Auth + Board Logic ===== -->
<script type="module">
  // Use the shared app
  import { auth, db, onAuthChanged, signOut } from './auth.js';

  // Only import the auth functions you call
  import {
    signInWithEmailAndPassword, createUserWithEmailAndPassword,
    sendPasswordResetEmail, sendEmailVerification
  } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js";

  import {
    doc, getDoc, setDoc, updateDoc, serverTimestamp,
    collection, query, orderBy, onSnapshot, addDoc, deleteDoc, getDocs, where, Timestamp
  } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js";

  // ===== Admin allow-list (fallback while profiles populate) =====
  const BOARD_EMAILS = ["theflying64@gmail.com"];
  const FALLBACK_EMAILS = [];

  // Role / profile state
  let currentUser = null;
  let isAdmin = false;

  // UI refs (auth)
  const openBtn    = document.getElementById('signinBtn');
  const modal      = document.getElementById('authModal');
  const closeBtn   = document.getElementById('closeModal');
  const emailEl    = document.getElementById('email');
  const passEl     = document.getElementById('password');
  const inviteEl   = document.getElementById('invite');
  const firstEl    = document.getElementById('firstName');
  const lastEl     = document.getElementById('lastName');
  const doSignIn   = document.getElementById('doSignIn');
  const doSignUp   = document.getElementById('doSignUp');
  const doReset    = document.getElementById('doReset');
  const signOutBtn = document.getElementById('signOutBtn');
  const msgEl      = document.getElementById('authMsg');

  // Board UI refs
  const hintEl     = document.getElementById('msgHint');
  const feedEl     = document.getElementById('messages');
  const newPostBtn = document.getElementById('newPostBtn');
  const notifyBtn  = document.getElementById('notifyBtn'); // may be null

  // New Post modal refs
  const postModal        = document.getElementById('postModal');
  const closePost        = document.getElementById('closePost');
  const postCancel       = document.getElementById('postCancel');
  const postSubmitOnly   = document.getElementById('postSubmitOnly'); // may be null
  const postSubmitNotify = document.getElementById('postSubmitNotify');
  const postNameEl       = document.getElementById('postName');
  const postEmailEl      = document.getElementById('postEmail');
  const postWhenEl       = document.getElementById('postWhen');
  const postTextEl       = document.getElementById('postText');
  const postMsgEl        = document.getElementById('postMsg');

  // Allow opening via #signin
  if (location.hash === '#signin') { openBtn?.click(); }
  window.addEventListener('hashchange', () => {
    if (location.hash === '#signin') openBtn?.click();
  });

  // Helpers
  const say  = (t, isErr=false)=>{ msgEl.textContent = t; msgEl.style.color  = isErr ? '#ffb4b4' : '#9fb1c3'; };
  const psay = (t, isErr=false)=>{ postMsgEl.textContent = t; postMsgEl.style.color = isErr ? '#ffb4b4' : '#9fb1c3'; };
  const escapeHtml = (s)=> (s||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;");
  function toLocalDatetimeValue(d=new Date()){
    const pad = (n)=> String(n).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

  // Auth modal open/close
  function openAuth(){ modal.classList.add('open'); modal.setAttribute('aria-hidden','false'); say(""); }
  function closeAuth(){ modal.classList.remove('open'); modal.setAttribute('aria-hidden','true'); }
  openBtn?.addEventListener('click', openAuth);
  closeBtn?.addEventListener('click', closeAuth);
  modal?.addEventListener('click', e => { if (e.target === modal) closeAuth(); });

  // New Post modal open/close
  function openPost(){
    if (!currentUser){ openAuth(); return; }
    if (!currentUser.emailVerified){ alert("Verify your email first."); return; }
    postEmailEl.value = currentUser.email || "";
    postNameEl.value = (currentUser.email || "").split("@")[0];
    postTextEl.value = "";
    postWhenEl.value = toLocalDatetimeValue(new Date());
    psay("");
    postModal.classList.add('open');
    postModal.setAttribute('aria-hidden','false');
    postNameEl.focus();
  }
  function closePostModal(){
    postModal.classList.remove('open');
    postModal.setAttribute('aria-hidden','true');
  }
  newPostBtn?.addEventListener('click', openPost);
  closePost?.addEventListener('click', closePostModal);
  postCancel?.addEventListener('click', closePostModal);
  postModal?.addEventListener('click', e => { if (e.target === postModal) closePostModal(); });

  // Role loader
  async function reloadRole(){
    isAdmin = false;
    if (!currentUser) return;
    if (currentUser.email && BOARD_EMAILS.includes(currentUser.email)) {
      isAdmin = true; return;
    }
    try{
      const pref = doc(db, "profiles", currentUser.uid);
      const snap = await getDoc(pref);
      const role = snap.exists() ? (snap.data().role || "").toLowerCase() : "";
      if (role === "admin" || role === "superadmin") isAdmin = true;
    }catch{/* ignore */}
  }

  // âœ… Use our wrapper from auth.js (not onAuthStateChanged)
  onAuthChanged(async (user)=>{
    currentUser = user || null;
    const verified = !!user?.emailVerified;

    if (user) {
      const shortEmail = user.email && user.email.length > 25 ? user.email.slice(0, 25) + "â€¦" : (user?.email || "");
      document.getElementById('signinBtn').textContent = verified
        ? `Account â€“ ${shortEmail}`
        : `Unverified â€“ ${shortEmail}`;

      await reloadRole();

      newPostBtn.style.display = verified ? "inline-block" : "none";
      hintEl.textContent = verified
        ? "Share updates with the club."
        : "Please verify your email to post.";
    } else {
      document.getElementById('signinBtn').textContent = "Sign In";
      newPostBtn.style.display = "none";
      hintEl.textContent = "Board notices and member updates appear here.";
    }
  });

  // Sign in / up / reset / out
  doSignIn.addEventListener('click', async ()=>{
    const email = emailEl.value.trim();
    const pass  = passEl.value;
    if (!email || !pass) return say("Enter email and password.", true);
    try { await signInWithEmailAndPassword(auth, email, pass); say("Signed in."); closeAuth(); }
    catch(err){ say(err.message, true); }
  });

  doSignUp.addEventListener('click', async ()=>{
    const email = emailEl.value.trim();
    const pass  = passEl.value;
    const code  = (inviteEl.value || "").trim();
    const first = firstEl.value.trim();
    const last  = lastEl.value.trim();

    if (!email || !pass || !code || !first || !last)
      return say("First and last name, email, password, and invite code are required.", true);

    try {
      // Validate invite
      const inviteRef  = doc(db, "invites", code);
      const inviteSnap = await getDoc(inviteRef);
      if (!inviteSnap.exists()) return say("Invalid invite code.", true);
      const d = inviteSnap.data();
      if (d.disabled === true) return say("This invite code is disabled.", true);
      if (d.used === true && d.multi !== true) return say("This invite code has already been used.", true);

      // Create auth user
      const cred = await createUserWithEmailAndPassword(auth, email, pass);
      await sendEmailVerification(cred.user);

      // Create profile + member docs immediately
      const baseData = {
        uid: cred.user.uid,
        email,
        firstName: first,
        lastName : last,
        emailVerified: false,
        active: true,
        role: "user",
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      };
      await Promise.all([
        setDoc(doc(db, "profiles", cred.user.uid), baseData, { merge: true }),
        setDoc(doc(db, "members",  cred.user.uid), baseData, { merge: true })
      ]);

      // Mark invite touched
      await updateDoc(inviteRef, {
        used: true,
        usedByLast: cred.user.uid,
        usedAtLast: serverTimestamp()
      });

      say("Account created! Check your inbox to verify your email.");
    } catch(err){ say(err.message, true); }
  });

  doReset.addEventListener('click', async ()=>{
    const email = emailEl.value.trim();
    if (!email) return say("Enter your email first.", true);
    try { await sendPasswordResetEmail(auth, email); say("Password reset email sent."); }
    catch(err){ say(err.message, true); }
  });

  signOutBtn.addEventListener('click', async ()=>{ await signOut(auth); say("Signed out."); });

  // Post creation
  async function createPost(){
    if (!currentUser){ psay("Please sign in.", true); return null; }
    if (!currentUser.emailVerified){ psay("Verify your email first.", true); return null; }

    const displayName = (postNameEl.value || "").trim();
    const text        = (postTextEl.value || "").trim();
    if (!displayName){ psay("Display name is required.", true); return null; }
    if (!text)       { psay("Message cannot be empty.", true); return null; }

    let whenTs = Timestamp.fromDate(new Date());
    const raw = (postWhenEl.value || "").trim();
    if (raw){
      const dt = new Date(raw);
      if (!isNaN(dt.getTime())) whenTs = Timestamp.fromDate(dt);
    }

    const ref = await addDoc(collection(db,"board"), {
      text,
      authorEmail: currentUser.email || "",
      authorName: displayName,
      authorUid: currentUser.uid,
      createdAt: whenTs,
      updatedAt: serverTimestamp()
    });
    return { id: ref.id, text, displayName, when: whenTs.toDate() };
  }

  // Fetch active member emails (admin only)
  async function getActiveEmails(){
    if (isAdmin){
      try{
        const emails = [];
        const qProfiles = query(collection(db,"profiles"), where("active","==", true));
        const snap = await getDocs(qProfiles);
        snap.forEach(docu=>{
          const d = docu.data();
          const e = (d.email || "").trim();
          if (e) emails.push(e);
        });
        if (emails.length) return emails;
      }catch{/* fallback */}
    }
    return FALLBACK_EMAILS;
  }

  function openMailto(allBcc, subject, body){
    const mailto = `mailto:?bcc=${encodeURIComponent(allBcc.join(','))}&subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
    window.location.href = mailto;
  }

  // Submit listeners (guard optional elements)
  if (postSubmitOnly) {
    postSubmitOnly.addEventListener('click', async ()=>{
      try{
        const created = await createPost();
        if (created){ closePostModal(); }
      }catch(err){ psay(err.message, true); }
    });
  }

  postSubmitNotify?.addEventListener('click', async ()=>{
    try{
      if (!isAdmin){ psay("Only admins can notify all members.", true); return; }
      const created = await createPost();
      if (!created) return;

      const all = await getActiveEmails();
      if (!all.length){ closePostModal(); alert("Post created, but no member emails found to notify."); return; }

      const whenStr = created.when.toLocaleString();
      const subject = "New Message on The Flying 64th Website";
      const body =
`From: ${created.displayName}
When: ${whenStr}

${created.text}

â€” This message was posted on the Member Message Board (The Flying 64th).`;

      openMailto(all, subject, body);
      closePostModal();
    }catch(err){ psay(err.message, true); }
  });

  notifyBtn && notifyBtn.addEventListener('click', ()=>{
    if (!currentUser){ openAuth(); return; }
    if (!currentUser.emailVerified){ alert("Verify your email first."); return; }
    if (!isAdmin){ alert("Only admins can notify all members."); return; }
    openPost();
  });

  // Live feed
  const qBoard = query(collection(db,"board"), orderBy("createdAt","desc"));
  onSnapshot(qBoard, (snap)=>{
    const verified = !!currentUser?.emailVerified;
    feedEl.innerHTML = "";
    snap.forEach(d=>{
      const m = d.data();
      const ts = m.createdAt?.toDate ? m.createdAt.toDate() : null;
      const when = ts ? ts.toLocaleString() : "â€¦";
      const canDelete = verified && (isAdmin || currentUser?.uid === m.authorUid);

      const div = document.createElement("div");
      div.className = "msg";
      div.innerHTML = `
        <div class="msg-top">
          <div class="msg-meta">
            <strong>${escapeHtml(m.authorName || "Member")}</strong>
            <span> â€¢ ${when}</span>
            <div style="color:#9fb1c3;font-size:12px">${escapeHtml(m.authorEmail || "")}</div>
          </div>
          ${ canDelete ? `<button class="iconbtn" data-del="${d.id}">ðŸ—‘ Delete</button>` : "" }
        </div>
        <div style="margin-top:6px;">${escapeHtml(m.text || "")}</div>
      `;
      feedEl.appendChild(div);
    });

    // Wire delete buttons
    [...feedEl.querySelectorAll("[data-del]")].forEach(btn=>{
      btn.addEventListener("click", async ()=>{
        const id = btn.getAttribute("data-del");
        if (!id) return;
        if (!confirm("Delete this message?")) return;
        try{ await deleteDoc(doc(db,"board",id)); }catch(e){ alert(e.message); }
      });
    });
  });
</script>
